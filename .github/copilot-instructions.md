Copilot, you are my senior engineer. Apply the following changes end-to-end.

Context: We’re enhancing a Kali-focused MCP server into a production-ready service with:

Enrollment + API key auth

Safe, schema-validated tool calls

Artifact storage with auto-parsed summaries

Per-server memory hooks (stubs)

Guardrails (scope, destructive toggles)

Dashboard-friendly HTTP endpoints

Systemd installer & quick start

Optional WSS + mTLS scaffolding

Target repo: khalilpreview/MCP-Kali-Server (Python). Keep code clean, typed, and documented.

0) Project layout update

Create/ensure this structure:

.
├─ kali_server.py
├─ install.sh
├─ mcp_server/
│  ├─ __init__.py
│  ├─ api.py
│  ├─ auth.py
│  ├─ artifacts.py
│  ├─ memory.py
│  ├─ scope.py
│  ├─ tools.py
│  ├─ schemas/
│  │  └─ tools/
│  │     ├─ net_scan_basic.json
│  │     └─ (room for more)
│  └─ util.py
├─ requirements.txt
└─ README.md


Use FastAPI for HTTP, uvicorn runner, and keep MCP JSON-RPC handling compatible with current behavior.

1) Dependencies

Update requirements.txt:

fastapi
uvicorn
pydantic>=2
websockets
jsonschema
ipaddress
cryptography
python-dateutil

2) Auth & Enrollment

Implement enrollment: one-time token generated by installer (/etc/mcp-kali/enroll.json).

Endpoint POST /enroll accepts {id, token, label}; returns {server_id, api_key, label} and persists to /etc/mcp-kali/credentials.json.

Add Bearer API key middleware for all protected routes.

Add helper to load/save JSON creds safely.

Files

mcp_server/auth.py

load_enroll(), save_api_credentials(), load_api_credentials()

require_api_key(request) FastAPI dependency

Utility to generate strong API keys.

kali_server.py / mcp_server/api.py

POST /enroll (public—uses enrollment token).

All other endpoints require Authorization: Bearer <api_key>.

3) Guardrails / Scope

File /etc/mcp-kali/scope.json with:

{
  "allowed_cidrs": ["10.0.0.0/8","192.168.0.0/16"],
  "allow_destructive": false
}


Implement mcp_server/scope.py:

in_scope(target: str) -> bool (supports IP/CIDR, resolves hostnames).

is_destructive(tool_name, args) -> bool.

Reject out-of-scope or destructive actions unless allowed; return clear 403 JSON.

4) Tools API (schema-validated)

Implement tools/list and tools/call endpoints (HTTP) + MCP methods internally.

Use JSON Schema under mcp_server/schemas/tools/ to validate arguments.

Initial tool: net.scan_basic

Schema at schemas/tools/net_scan_basic.json:

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "net.scan_basic",
  "type": "object",
  "properties": {
    "target": { "type": "string", "pattern": "^[0-9A-Za-z.:/_-]+$" },
    "ports": { "type": "string" },
    "fast": { "type": "boolean", "default": true }
  },
  "required": ["target"],
  "additionalProperties": false
}


Behavior:

Build an nmap invocation safely (no shell). Suggested args: ["nmap","-sV","--open"] plus -F if fast=true, optional -p ports, host-timeout 2m, output XML to stdout.

Enforce scope on target.

Timeout 120s default.

mcp_server/tools.py

list_tools() returns array of tools with names, descriptions, and schema refs.

call_tool(name, args) validates via jsonschema, dispatches to safe runners.

Return structured result: { rc, summary, artifact_uri, findings }.

5) Artifacts & Auto-summaries

Save raw outputs under /var/lib/mcp/artifacts/{server_id}/{run_id}/.

Files:

raw.xml (or raw.txt)

summary.txt

parsed.json (ports/services)

Implement simple nmap XML parser to extract {host, port, service, version}.

Return artifact_uri as artifact://{server_id}/{run_id}/raw.xml.

mcp_server/artifacts.py

save_artifact(server_id, kind, content) -> dict

list_artifacts(server_id, limit=50, offset=0)

read_artifact(uri) -> bytes/str

parse_nmap_xml(xml_str) -> dict

summarize(text: str) -> str (placeholder; simple heuristic summary, not an LLM call)

Endpoints

GET /artifacts/list

GET /artifacts/read?uri=...

6) Memory hooks (stubs)

mcp_server/memory.py

record_observation(server_id, kind, summary, parsed) -> persist lightweight facts (sqlite or JSONL for now).

search_memory(server_id, query) -> placeholder returning recent summaries.

Wire this after each successful tool run.

7) Health & Dashboard Handshake

GET /health returns { ok: true, server_id, caps: {...}, time }.

GET /tools/list returns tool metadata (names, brief descriptions, schema links).

POST /tools/call accepts { name, arguments }.

Test connection flow (used by dashboard):

Call /health then /tools/list. If both succeed → connection OK.

8) Optional WSS + mTLS scaffolding

Add config placeholders (don’t fully implement cert management; provide hooks):

Env vars:

MCP_TLS_CERT, MCP_TLS_KEY → if set, uvicorn runs TLS.

MCP_MTLS_CA → if set, require client certs (document TODO to validate certs).

Expose --bind host:port CLI arg (defaults to 0.0.0.0:5000).

9) Installer & Service

install.sh

Idempotent. Performs:

Clone/update repo to /opt/mcp-kali-server

Create mcpserver user

Create venv + install deps

Write systemd unit:

ExecStart=/opt/mcp-kali-server/venv/bin/python /opt/mcp-kali-server/kali_server.py --bind 0.0.0.0:5000

Generate /etc/mcp-kali/enroll.json with {id, token, created}

Print the JSON to stdout for the user to copy

Enable + start service.

Systemd unit content (embed in script):

[Unit]
Description=MCP Kali Server
After=network.target

[Service]
User=mcpserver
Group=mcpserver
WorkingDirectory=/opt/mcp-kali-server
ExecStart=/opt/mcp-kali-server/venv/bin/python /opt/mcp-kali-server/kali_server.py --bind 0.0.0.0:5000
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

10) API Signatures (exact)

POST /enroll (no auth)

Body: { "id": "string", "token": "string", "label": "string?" }

200: { "server_id": "string", "api_key": "string", "label": "string" }

GET /health (auth)

200: { "ok": true, "server_id": "string", "caps": {"tools":true,"artifacts":true,"memory":true}, "time": "ISO8601" }

GET /tools/list (auth)

200: { "tools": [ { "name":"net.scan_basic","description":"Nmap basic scan","schema":"/schemas/tools/net_scan_basic.json" } ] }

POST /tools/call (auth)

Body: { "name":"net.scan_basic", "arguments": { "target":"127.0.0.1","ports":"-p 80,443","fast":true } }

200: { "rc":0, "summary":"...", "artifact_uri":"artifact://.../raw.xml", "findings":[{"host":"...","port":80,"service":"http","version":"..."}] }

GET /artifacts/list (auth, query: limit, offset)

200: { "items":[ { "artifact_uri":"artifact://...", "summary":"...", "created":"ISO8601" } ], "nextOffset": 50 }

GET /artifacts/read (auth, query: uri)

200: file/bytes or { "content":"..." } depending on type

11) Code quality & safety

No shell=True. Always list-args to subprocess.

Timeouts on all external commands.

Input validation via JSON Schema + pydantic models for endpoints.

Centralized error handler returning {error, detail}.

Logging: method, duration, target, rc, artifact id (no secrets).

12) README updates

Add sections:

Install (one-liner using install.sh)

Enroll (curl examples)

Connect from dashboard (fields required)

Test connection (/health, /tools/list)

Run a scan (/tools/call example)

Artifacts & Memory (where stored, how to fetch)

Scope & Safety (configure /etc/mcp-kali/scope.json)

TLS/mTLS (optional) env vars

13) Example snippets Copilot must generate
kali_server.py (entrypoint)

Parse --bind.

Import mcp_server.api:app.

Run uvicorn with or without TLS based on envs.

mcp_server/api.py

Create FastAPI app.

Mount routes:

/enroll (public)

/health, /tools/list, /tools/call, /artifacts/list, /artifacts/read (auth)

Serve static schemas/ under /schemas/ for convenience.

mcp_server/tools.py

Implement list_tools().

Implement call_tool() dispatch for net.scan_basic.

Helper to run nmap safely; return parsed findings.

mcp_server/artifacts.py

Implement save/list/read + parse_nmap_xml().

mcp_server/memory.py

Implement simple JSONL persistence with record_observation().

mcp_server/auth.py

Enrollment + API key management.

require_api_key dependency.

mcp_server/scope.py

CIDR/hostname checks via ipaddress.

is_destructive() heuristic.

install.sh

Full script with echo of enrollment JSON at the end.

14) Acceptance tests (manual via curl)

After install:

Enroll

curl -sS -X POST "http://<HOST>:5000/enroll" \
  -H "Content-Type: application/json" \
  -d '{"id":"<printed-id>","token":"<printed-token>","label":"Kali-Lab-1"}'
# => returns api_key


Health

curl -sS "http://<HOST>:5000/health" -H "Authorization: Bearer <api_key>"


Tools list

curl -sS "http://<HOST>:5000/tools/list" -H "Authorization: Bearer <api_key>"


Run scan

curl -sS -X POST "http://<HOST>:5000/tools/call" \
  -H "Authorization: Bearer <api_key>" -H "Content-Type: application/json" \
  -d '{"name":"net.scan_basic","arguments":{"target":"127.0.0.1","fast":true}}'
# => returns summary, artifact_uri, findings


Artifacts

curl -sS "http://<HOST>:5000/artifacts/list" -H "Authorization: Bearer <api_key>"
curl -sS "http://<HOST>:5000/artifacts/read?uri=artifact://<id>/raw.xml" -H "Authorization: Bearer <api_key>"

15) Style

Python 3.10+, type hints, docstrings.

Small, testable functions.

Clear errors with HTTP status codes.

Do all of the above now. Generate or modify the necessary files with full implementations and comments.